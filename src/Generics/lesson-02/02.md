#### [keyof type operator Docs](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
#### [type assertions Docs](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)
#### [Record <keys, type Docs>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
#### [tuple types Docs](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)


## Ejercicio para la segunda semana de Genéricos en TS


### 1. Tipado de una función que crea sets
- **Problema a resolver**: Se necesita tipar correctamente una función que crea Sets de un tipo genérico.
- **Cómo resolverlo**: Permitir que la función acepte un parámetro genérico y se pase este genérico al constructor de Set.

### 2. Función que crea sets con tipo por defecto
- **Problema a resolver**: Modificar la función anterior para que, por defecto, el tipo de los `Sets` sea string en vez de `unknown`.
- **Cómo resolverlo**: Establecer un valor por defecto para el parámetro genérico de la función.

### 3. Inferencia de propiedades en componentes clonados
- **Problema a resolver**: Clonar un componente pasando sus propiedades de manera correcta usando genéricos para inferir el tipo de las propiedades del componente original.
- **Cómo resolverlo**: Usar clases como tipos y aprovechar los genéricos para inferir y pasar las propiedades al componente clonado.

### 4. Tipado correcto de una función reduce usando genéricos
- **Problema a resolver**: Usar genéricos para tipar correctamente una función `reduce` que transforma un arreglo de objetos en un objeto cuyas claves son valores de una propiedad de los objetos del arreglo.
- **Cómo resolverlo**: Utilizar genéricos para definir el tipo del valor acumulado en la función reduce, asegurándose de que TypeScript entienda que las claves del objeto resultante corresponden a los valores de cierta propiedad de los objetos del arreglo.

### 5. Evitar el tipo any en llamadas fetch usando genéricos
- **Problema a resolver**: Prevenir el uso del tipo any al trabajar con la función fetch para llamadas a APIs.
- **Cómo resolverlo**: Asignar un tipo genérico al valor de retorno de la función `fetch` para evitar el uso de `any`, mejorando así la seguridad de tipos en las respuestas de las llamadas a la API.

### 6. Nivel correcto de genéricos en funciones de configuración
- **Problema a resolver**: Tenemos una fuincion 'getHomePageFlags' la cual acepta 2 argumentos, 1. un objeto 'config' y 2. un callback que recibe un argumento 'flags'.
Tenemos que tipar nuestra funcion adecuadamente para satisfacer nuestros test.
- **Cómo resolverlo**: Sabemos (por la implementacion de nuestra funcion) que el arg 'flags' viene definido por 'config' (line 115), nuestro trabajo es primero tipar 'config' y asi 'propagarlo' correctamente a el tipo arg 'flags'

### 7. Tipado correcto de Object.keys
- **Problema a resolver**: `Object.keys` devuelve un arreglo de `string`, pero necesitamos que devuelva un arreglo de claves específicas del objeto.
- **Cómo resolverlo**: Utilizar un tipo genérico junto con un cast para asegurar que `TypeScript` entienda que el resultado es un arreglo de claves específicas del objeto, no solo `strings`.

### 8. Inferencia de tipo TypeScript
- **Problema a resolver**: Mejorar la inferencia de tipos en TypeScript para evitar el uso de `@ts-expect-error`.
- **Cómo resolverlo**: Usar un genérico que extienda tipos primitivos (como string y number) y asignarlo correctamente para mejorar la inferencia de tipos.

### 10. Aún más inferencia con TypeScript
- **Problema a resolver**: Crear una función que acepte un arreglo de strings `['asd', 'qwe', 'zxc']` y retorne el mismo array tipado correctamente infiriendo cada uno de sus miembros `Array<'asd' | 'qwe' | 'zxc'>`.
- **Cómo resolverlo**: Tipar los elementos del arreglo individualmente en lugar de tipar todo el arreglo, permitiendo así una mejor inferencia de tipo.

### 11. Aún más inferencia con TypeScript
- **Problema a resolver**: Tenemos una funcion que acepta 1 argumento `classes` el cual es un obketo `clave: valor` y esta devuelve otra funcion que acepta 2 args `type & otherClasses`. La idea de esta funcion es que podamos pasarle un objeto con classes (classes tailwind imaginarias) y despues poder `filtrar` por un `tipo` o `variante` y que esta nos devuelva la classes correspondientes a este `tipo/variante`. **nota**: nuestra implementacion tambien nos tiene que permitir al momento de `filtrar` poder agregar mas `classes` y estas tambien tienen que ser devueltas.
- **Cómo resolverlo**: Tipar lo que esperamos por nuestras classes y de acuerdo a ese tipo asignar un tipo a `type` y `otherClasses`.