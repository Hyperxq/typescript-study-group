#### [keyof type operator Docs](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
#### [type assertions Docs](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)
#### [Record <keys, type Docs>](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
#### [tuple types Docs](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)



### 1. you say hello I say goodbye
- **Problema a resolver**: Se le ha asignado la tarea de escribir una función que toma un mensaje de saludo como entrada y devuelve una respuesta basada en la entrada. La función debería devolver 'hola' si la entrada es 'adiós' y 'adiós' si la entrada es cualquier otro valor. Su tarea es utilizar genéricos para escribir correctamente la función para que pueda manejar cualquier tipo de entrada.
- **Cómo resolverlo**: Puede definir un parámetro de tipo genérico T para la función y luego usar restricciones para especificar que T debe ser una cadena. Luego puede utilizar la inferencia de tipos para inferir automáticamente el tipo del parámetro de entrada en función de la restricción..

### 2. runtime errors.. 
- **Problema a resolver**: la función remapPerson toma una clave `key` de tipo Key (donde Key es un tipo que extiende las claves de la interfaz Person) y un valor `value` de tipo Person[Key], y devuelve un nuevo valor de tipo Person[Key]. La función debería funcionar de la siguiente manera.:
- Si la key es "fecha de nacimiento", devuelve un nuevo objeto Fecha.
- En caso contrario, devuelve el valor original.
- **Cómo resolverlo**: piensa en `type assertion`. 

### 3. currying function 
- **Problema a resolver**: implementar una función de currying de TypeScript que toma tres argumentos de tipos T, U y V respectivamente, y devuelve un objeto con propiedades t, u y v que contiene los valores pasados. La función debe curry para aceptar un argumento a la vez antes devolver el objeto final. Utilice genéricos para escribir correctamente los parámetros de función y los tipos de retorno para cada paso del curry. Asegúrese de que el objeto devuelto contenga los tres valores en sus respectivas propiedades con los tipos correctos.
- **Cómo resolverlo**: algo esta mal en la implementacion, modifica la misma (usando genericos) para .tipar correctamente la funcion.  

### 4. cachee 
- **Problema a resolver**:  Refactorice la interfaz de caché y la función createCache en TypeScript para garantizar la seguridad de tipos en todas las operaciones de caché. La interfaz Cache debe tener un método de clonación que acepte una función de transformación con tipos de entrada y salida desconocidos y devuelva una nueva instancia de Cache con valores actualizados según la transformación. Actualice la función createCache para manejar correctamente la clonación asegurándose de que los elementos transformados mantengan sus tipos de datos originales. Utilice genéricos de forma eficaz para lograr seguridad de tipos tanto para los métodos de interfaz como para los detalles de implementación de la funcionalidad de caché.
- **Cómo resolverlo**: solo se necesita tipar `clone: (transform: (elem: unknown) => unknown) => Cache<unknown>`, la clave esta en que quiere hacer `clone`.

### 4. back to basics 
- **Problema a resolver**:   Refactorice la función getValue en TypeScript para asegurarse de que recupere correctamente los valores de un objeto en función de una clave determinada. La función debe ser lo suficientemente genérica para preservar el tipo de valor recuperado del objeto.. 
- **Cómo resolverlo**: vamos, yo se que tu sabes.
